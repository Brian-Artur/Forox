# Group by & Distint
lo que hace el distint, lo que va a hacer es recorrer toda la tabla
![ED2025-05-12_09.05.11](ED2025-05-12_09.05.11.md)
Mientras que GROUP BY opera con *los 5 P√©rez*, DISTINT opera s√≥lo con el primero. Entonces estamos recortando la cantidad de registros. Por lo que no tendremos acceso ellos, despu√©s de discriminarlos.

DISTINT s√≥lo muestra los resultados distintos.

Cuando hacemos GRUOP BY, debemos pensar que estamos trabajando agrupaciones, en vez de registros sueltos. Entonces, las operaciones que hagamos, van a computar por el grupo.

El GROUP BY tiene prioridad. Por eso, aunque hagamos un orden de los registros de la tabla, se la va a pasar de largo. Nos va a devolver ese primer registro en el orden original.

# Having
HAVING es como un **WHERE2.0**, es utilizado para crear condiciones, pero a diferencia de la clausula WHERE, HAVING **permite utilizar funciones** como `COUNT`, `MAX`, `SUM`, etc.

WHERE no permite utilizar funciones. Nos va a dar error.

![ED2025-05-12_09.34.16](ED2025-05-12_09.34.16.md)

> Es una buena pr√°ctica realizar el `COUNT()` sobre el id de una tabla porque es una valor obligatorio; a parte de que es √∫nico.

![ED2025-05-12_09.59.09|450](ED2025-05-12_09.59.09.md)  
Vemos que est√°n funcionando igual.

![ED2025-05-12_10.04.09|500](ED2025-05-12_10.04.09.md)

Normalmente la gente coloca en el HAVING lo mismo que coloca en el GROUP BY y en esa consulta muestra esa misma columna. 

![ED2025-05-12_10.15.15|500](ED2025-05-12_10.15.15.md)

Si quieres estudiar SQL con ChatGPT, dile que te explique la consulta sin aumenta sa complejidad de la misma; que no le a√±ada m√°s cosas.

# Describe
`DESCRIBE` + TABLA : nos da una tabla con las caracter√≠sticas de los campos de la tabla que estamos consultando.  
![describe](Pasted%20image%2020250512121454.png)

# Select + Group by + Having

### **¬øEs cierto que `HAVING`, `GROUP BY` y `SELECT` suelen usar el mismo campo?**  
‚úÖ **S√≠, pero no es una regla inquebrantable.** Es una pr√°ctica com√∫n porque `HAVING` filtra **grupos de datos** (creados por `GROUP BY`), y para que sea legible, solemos mostrar ese campo en el `SELECT`.  

---  

### **üîç Estructura t√≠pica de una consulta con `GROUP BY` y `HAVING`**  
Imagina que eres un hechicero de datos y tienes una tabla `ventas` con:  
- `producto_id`  
- `cantidad_vendida`  
- `fecha_venta`  

```sql
SELECT 
    producto_id,                  -- üëà Campo agrupado (GROUP BY)  
    SUM(cantidad_vendida) AS total_vendido  -- üëà Funci√≥n de agregaci√≥n  
FROM ventas  
GROUP BY producto_id              -- üëà Agrupamos por producto  
HAVING SUM(cantidad_vendida) > 100  -- üëà Filtramos grupos  
```  

### **üéØ ¬øPor qu√© esta estructura?**  
1. **`GROUP BY`** ‚Üí Agrupa filas en "cubos" (ej: todos los datos de un `producto_id`).  
2. **Funciones de agregaci√≥n** (`SUM`, `AVG`, `COUNT`...) ‚Üí Calculan valores por grupo (ej: suma de ventas).  
3. **`HAVING`** ‚Üí Filtra **los grupos** (no filas individuales como `WHERE`).  

---  

### **üí° ¬øCu√°ndo usamos `HAVING` en el mismo campo que `GROUP BY`?**  
Cuando el filtro depende **del grupo completo**, no de una fila. Ejemplo:  

‚ùå **`WHERE`** (filtra filas antes de agrupar):  
```sql
SELECT producto_id, SUM(cantidad_vendida)  
FROM ventas  
WHERE cantidad_vendida > 10  -- Filtra ventas individuales > 10  
GROUP BY producto_id  
```  

‚úÖ **`HAVING`** (filtra despu√©s de agrupar):  
```sql
SELECT producto_id, SUM(cantidad_vendida)  
FROM ventas  
GROUP BY producto_id  
HAVING SUM(cantidad_vendida) > 100  -- Filtra productos con +100 ventas en TOTAL  
```  

---  

### **üöÄ Casos donde `HAVING` no usa el mismo campo que `GROUP BY`**  
¬°Tambi√©n puedes filtrar por campos calculados! Ejemplo:  

```sql
SELECT 
    producto_id,  
    AVG(cantidad_vendida) AS promedio_ventas  
FROM ventas  
GROUP BY producto_id  
HAVING AVG(cantidad_vendida) > 50  -- üëà Filtra por promedio, no por producto_id  
```  

---  

### **üìå Conclusi√≥n**  
- **S√≠, es com√∫n que `SELECT`, `GROUP BY` y `HAVING` usen el mismo campo** (para claridad).  
- **Pero `HAVING` puede filtrar por cualquier campo calculado en el grupo** (sumas, promedios, conteos...).  
- **`HAVING` es el guardi√°n de los grupos**, mientras que `WHERE` es el filtro de filas.  

¬øTe qued√≥ claro, futuro maestro de los joins y subconsultas? üòé Si tienes m√°s dudas, ¬°aqu√≠ estoy como un √≠ndice bien optimizado para responder en milisegundos!

# Let & var
#TypeScript 
Tanto el var , let y const realizan ese izamiento (hoising) pero la diferencia m√°s clara es que tanto con let, como con `const` dan error porque JS los coloca en la TDZ (zona temporalmente muerta). Podemos pensarlo como un embri√≥n que se est√° gestando pero que a√∫n no ha nacido.

# Desestructuraci√≥n de objetos  
Ojo, no confundir el tipado de una variable creada en el par√°metro de una funci√≥n, con la desestructuraci√≥n de otro objeto, ya existente, en los par√°metros. Pues en ese segundo caso no estar√≠amos indicando el tipo, sino reasignando el tipo.
![ED2025-05-12_13.21.52|600](ED2025-05-12_13.21.52.md)

# Desestructuraci√≥n de Arreglos 

# Keyof  
![ED2025-05-12_18.59.15|450](ED2025-05-12_18.59.15.md)  
Para resolver ese falso error que da TypeScript, cunado operamos con *"clave"*, tenemos que a√±adirle el `as keyof Tipo_de_objeto` para que TS conf√≠e en nosotros. B√°sicamente le estamos diciendo que *"clave"* va a actuar como alguna de las claves que tiene el **Type Familia**. En este caso Familia tiene los tipos `string` y `string[]`. Por lo que va a ser similar a decirle: `as (string | string[])`.   
![tipos](Pasted%20image%2020250512191008.png)  
`clave` SIEMPRE va a ser de tipo **string**, pues se supone que se trata de la propiedad. Si lo pensamos en un JSON vemos que se escribe entrecomillado. 

La finalidad de toda esta parafernalia es que TS le asigne un tipo de dato a la variable resultante con la que operamos; que est√© acorde con el objeto original.

