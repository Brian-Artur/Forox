# Group by & Distint
lo que hace el distint, lo que va a hacer es recorrer toda la tabla
![ED2025-05-12_09.05.11](ED2025-05-12_09.05.11.md)
Mientras que GROUP BY opera con *los 5 Pérez*, DISTINT opera sólo con el primero. Entonces estamos recortando la cantidad de registros. Por lo que no tendremos acceso ellos, después de discriminarlos.

DISTINT sólo muestra los resultados distintos.

Cuando hacemos GRUOP BY, debemos pensar que estamos trabajando agrupaciones, en vez de registros sueltos. Entonces, las operaciones que hagamos, van a computar por el grupo.

El GROUP BY tiene prioridad. Por eso, aunque hagamos un orden de los registros de la tabla, se la va a pasar de largo. Nos va a devolver ese primer registro en el orden original.

# Having
HAVING es como un **WHERE2.0**, es utilizado para crear condiciones, pero a diferencia de la clausula WHERE, HAVING **permite utilizar funciones** como `COUNT`, `MAX`, `SUM`, etc.

WHERE no permite utilizar funciones. Nos va a dar error.

![ED2025-05-12_09.34.16](ED2025-05-12_09.34.16.md)

> Es una buena práctica realizar el `COUNT()` sobre el id de una tabla porque es una valor obligatorio; a parte de que es único.

![ED2025-05-12_09.59.09|450](ED2025-05-12_09.59.09.md)  
Vemos que están funcionando igual.

![ED2025-05-12_10.04.09|500](ED2025-05-12_10.04.09.md)

Normalmente la gente coloca en el HAVING lo mismo que coloca en el GROUP BY y en esa consulta muestra esa misma columna. 

![ED2025-05-12_10.15.15|500](ED2025-05-12_10.15.15.md)

Si quieres estudiar SQL con ChatGPT, dile que te explique la consulta sin aumenta sa complejidad de la misma; que no le añada más cosas.

# Describe
`DESCRIBE` + TABLA : nos da una tabla con las características de los campos de la tabla que estamos consultando.  
![describe](Pasted%20image%2020250512121454.png)


# Let & var
Tanto el var , let y const realizan ese izamiento (hoising) pero la diferencia más clara es que tanto con let, como con `const` dan error porque JS los coloca en la TDZ (zona temporalmente muerta). Podemos pensarlo como un embrión que se está gestando pero que aún no ha nacido.

# Desestructuración de objetos  
Ojo, no confundir el tipado de una variable creada en el parámetro de una función, con la desestructuración de otro objeto, ya existente, en los parámetros. Pues en ese segundo caso no estaríamos indicando el tipo, sino reasignando el tipo.
![ED2025-05-12_13.21.52|550](ED2025-05-12_13.21.52.md)

# Desestructuración de Arreglos 